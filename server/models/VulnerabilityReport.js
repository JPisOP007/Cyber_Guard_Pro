const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  id: String, // CVE ID or custom ID
  title: {
    type: String,
    required: true
  },
  description: String,
  severity: {
    type: String,
    enum: ['info', 'low', 'medium', 'high', 'critical'],
    required: true
  },
  cvssScore: {
    type: Number,
    min: 0,
    max: 10
  },
  cvssVector: String,
  cwe: String, // Common Weakness Enumeration
  category: {
    type: String,
    enum: ['network', 'web', 'system', 'database', 'application', 'configuration'],
    required: true
  },
  target: {
    type: String,
    required: true // IP, domain, or application
  },
  port: Number,
  protocol: String,
  service: String,
  plugin: String,
  method: {
    type: String,
    enum: ['passive', 'active', 'heuristic', 'inferred'],
    default: 'heuristic'
  },
  verified: {
    type: Boolean,
    default: false
  },
  confidence: {
    type: Number,
    min: 0,
    max: 100,
    default: 50
  },
  evidenceLevel: {
    type: String,
    enum: ['none', 'low', 'moderate', 'strong'],
    default: 'none'
  },
  evidence: {
    request: String,
    response: String,
    screenshot: String,
    logs: [String]
  },
  proof: String,
  solution: String,
  references: [String],
  tags: [String],
  status: {
    type: String,
    enum: ['open', 'confirmed', 'false-positive', 'resolved', 'wont-fix', 'duplicate'],
    default: 'open'
  },
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  dueDate: Date,
  resolvedDate: Date,
  resolutionNotes: String,
  retestRequired: {
    type: Boolean,
    default: false
  },
  retestDate: Date,
  businessImpact: {
    type: String,
    enum: ['none', 'low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  exploitability: {
    type: String,
    enum: ['none', 'difficult', 'moderate', 'easy'],
    default: 'moderate'
  }
});

const vulnerabilityReportSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  scanId: {
    type: String,
    required: true,
    unique: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  scanType: {
    type: String,
    enum: ['full', 'quick', 'targeted', 'compliance', 'retest'],
    default: 'full'
  },
  targets: [{
    type: String, // IPs, domains, or ranges
    required: true
  }],
  status: {
    type: String,
    enum: ['pending', 'running', 'completed', 'failed', 'cancelled'],
    default: 'pending'
  },
  progress: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },
  startTime: {
    type: Date,
    default: Date.now
  },
  endTime: Date,
  duration: Number, // in milliseconds
  
  // Scan configuration
  config: {
    scanTypes: [{
      type: String,
      enum: ['port', 'vulnerability', 'ssl', 'dns', 'web', 'malware']
    }],
    intensity: {
      type: String,
      enum: ['light', 'normal', 'aggressive'],
      default: 'normal'
    },
    timeout: {
      type: Number,
      default: 300000 // 5 minutes
    },
    maxConcurrency: {
      type: Number,
      default: 10
    },
    userAgent: String,
    exclusions: [String]
  },
  
  // Results
  vulnerabilities: [vulnerabilitySchema],
  
  summary: {
    totalTargets: Number,
    activeTargets: Number,
    totalVulnerabilities: Number,
    severityCounts: {
      critical: {
        type: Number,
        default: 0
      },
      high: {
        type: Number,
        default: 0
      },
      medium: {
        type: Number,
        default: 0
      },
      low: {
        type: Number,
        default: 0
      },
      info: {
        type: Number,
        default: 0
      }
    },
    categoryCounts: {
      network: {
        type: Number,
        default: 0
      },
      web: {
        type: Number,
        default: 0
      },
      system: {
        type: Number,
        default: 0
      },
      database: {
        type: Number,
        default: 0
      },
      application: {
        type: Number,
        default: 0
      },
      configuration: {
        type: Number,
        default: 0
      }
    },
    riskScore: {
      type: Number,
      min: 0,
      max: 100,
      default: 0
    }
  },
  
  // Technical details
  scanEngine: {
    name: String,
    version: String
  },
  plugins: [{
    name: String,
    version: String,
    enabled: Boolean
  }],
  
  // Export and sharing
  exported: {
    pdf: {
      generated: {
        type: Boolean,
        default: false
      },
      url: String,
      generatedAt: Date
    },
    csv: {
      generated: {
        type: Boolean,
        default: false
      },
      url: String,
      generatedAt: Date
    },
    json: {
      generated: {
        type: Boolean,
        default: false
      },
      url: String,
      generatedAt: Date
    }
  },
  
  shared: [{
    email: String,
    sharedAt: Date,
    access: {
      type: String,
      enum: ['read', 'comment', 'edit'],
      default: 'read'
    }
  }],
  
  // Compliance and reporting
  compliance: [{
    framework: String,
    requirements: [{
      id: String,
      status: {
        type: String,
        enum: ['pass', 'fail', 'warning', 'not-tested'],
        default: 'not-tested'
      },
      description: String
    }]
  }],
  
  // Notifications sent
  notifications: [{
    type: {
      type: String,
      enum: ['email', 'sms', 'webhook', 'slack']
    },
    recipients: [String],
    sentAt: Date,
    status: {
      type: String,
      enum: ['sent', 'failed', 'pending'],
      default: 'pending'
    }
  }],
  
  // Metadata
  tags: [String],
  notes: String,
  isPublic: {
    type: Boolean,
    default: false
  },
  
  // Archived reports
  archived: {
    type: Boolean,
    default: false
  },
  archivedAt: Date
}, {
  timestamps: true
});

// Indexes
vulnerabilityReportSchema.index({ userId: 1, createdAt: -1 });
vulnerabilityReportSchema.index({ scanId: 1 });
vulnerabilityReportSchema.index({ status: 1 });
vulnerabilityReportSchema.index({ 'summary.riskScore': -1 });
vulnerabilityReportSchema.index({ targets: 1 });

// Virtual for scan duration in readable format
vulnerabilityReportSchema.virtual('durationFormatted').get(function() {
  if (!this.duration) return null;
  const seconds = Math.floor(this.duration / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
});

// Method to update progress
vulnerabilityReportSchema.methods.updateProgress = function(progress) {
  this.progress = Math.min(100, Math.max(0, progress));
  return this.save();
};

// Method to add vulnerability
vulnerabilityReportSchema.methods.addVulnerability = function(vulnData) {
  this.vulnerabilities.push(vulnData);
  this.updateSummary();
  return this.save();
};

// Method to update summary
vulnerabilityReportSchema.methods.updateSummary = function() {
  const summary = {
    totalTargets: this.targets.length,
    activeTargets: this.targets.length, // This would be calculated based on actual results
    totalVulnerabilities: this.vulnerabilities.length,
    severityCounts: {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    },
    categoryCounts: {
      network: 0,
      web: 0,
      system: 0,
      database: 0,
      application: 0,
      configuration: 0
    },
    riskScore: 0
  };
  
  // Count by severity and category
  this.vulnerabilities.forEach(vuln => {
    if (summary.severityCounts[vuln.severity] !== undefined) {
      summary.severityCounts[vuln.severity]++;
    }
    if (summary.categoryCounts[vuln.category] !== undefined) {
      summary.categoryCounts[vuln.category]++;
    }
  });
  
  // Calculate risk score based on vulnerabilities
  const weights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
  let totalRisk = 0;
  Object.keys(weights).forEach(severity => {
    totalRisk += summary.severityCounts[severity] * weights[severity];
  });
  
  // Normalize to 0-100 scale (adjust divisor based on expected max vulnerabilities)
  summary.riskScore = Math.min(100, Math.round(totalRisk / 10));
  
  this.summary = summary;
};

// Method to complete scan
vulnerabilityReportSchema.methods.completeScan = function() {
  this.status = 'completed';
  this.endTime = new Date();
  this.duration = this.endTime - this.startTime;
  this.progress = 100;
  this.updateSummary();
  return this.save();
};

// Method to fail scan
vulnerabilityReportSchema.methods.failScan = function(error) {
  this.status = 'failed';
  this.endTime = new Date();
  this.duration = this.endTime - this.startTime;
  this.notes = error || 'Scan failed';
  return this.save();
};

module.exports = mongoose.model('VulnerabilityReport', vulnerabilityReportSchema);